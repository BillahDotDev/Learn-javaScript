ES6+ Features
1. Arrow Functions: Arrow functions provide a concise syntax for writing anonymous functions. 

They lexically bind the this value, making it more predictable and avoiding the need for bind, call, or apply.

// ES5
function add(a, b) {
return a + b;
}

// ES6
const add = (a, b) => a + b;

2. Template Literals: Template literals allow embedding expressions inside strings, 
making string interpolation easier and more readable.

const name = 'John';
console.log(`Hello, ${name}!`);

3. Destructuring Assignment: Destructuring allows extracting values from arrays or objects into distinct variables, 
making code more concise.

// Array destructuring
const [a, b] = [1, 2];

// Object destructuring
const { x, y } = { x: 1, y: 2 };

4. Spread Syntax: Spread syntax allows an iterable such as an array expression or string to be expanded in places 
where zero or more arguments (for function calls) or elements (for array literals) are expected.

const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];

5. Rest Parameters: The rest parameter syntax allows representing an indefinite number of arguments as an array, simplifying function definitions.

function sum(...numbers) {
    return numbers.reduce((acc, curr) => acc + curr, 0);
}

6. Promises: Promises provide a cleaner alternative to callback-based asynchronous code, making it easier to reason about and handle asynchronous operations.

function fetchData() {
    return new Promise((resolve, reject) => {
        // Asynchronous operation
        if (success) {
            resolve(data);
        } else {
            reject(error);
        }
    });
}

7. Classes: ES6 introduced class syntax, providing a more familiar and convenient way to create objects and deal with inheritance.

class Person {
    constructor(name) {
        this.name = name;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}.`);
    }
}

const person = new Person('John');
person.greet();
